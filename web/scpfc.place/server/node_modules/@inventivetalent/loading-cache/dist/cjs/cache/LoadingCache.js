"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadingCache = void 0;
const SimpleCache_1 = require("./SimpleCache");
const events_1 = require("events");
const CacheEvents_1 = require("../CacheEvents");
class LoadingCache extends events_1.EventEmitter {
    constructor(options, loader, multiLoader, internalCache) {
        super({});
        if (internalCache) {
            this._cache = internalCache(options);
        }
        else {
            this._cache = new SimpleCache_1.SimpleCache();
        }
        this.loader = loader;
        this.multiLoader = multiLoader;
        CacheEvents_1.CacheEvents.forward(this._cache, this);
    }
    get cache() {
        return this._cache;
    }
    get options() {
        return this.cache.options;
    }
    get stats() {
        return this.cache.stats;
    }
    ///// GET
    getIfPresent(key) {
        return this.cache.getIfPresent(key);
    }
    get(key, mappingFunction, forceLoad = false) {
        return this._get(key, mappingFunction, forceLoad);
    }
    /**
     * @internal
     */
    _get(key, mappingFunction, forceLoad = false) {
        if (!forceLoad) {
            const present = this.getIfPresent(key);
            if (present) {
                return present;
            }
        }
        if (mappingFunction) {
            return this.cache._get(key, mappingFunction, true);
        }
        if (this.loader) {
            return this._get(key, this.loader, true);
        }
        return undefined;
    }
    /// GET ALL
    getAllPresent(keys) {
        return this.cache.getAllPresent(keys);
    }
    getAll(keys, mappingFunction) {
        return this._getAll(keys, mappingFunction);
    }
    /**
     * @internal
     */
    _getAll(keys, mappingFunction) {
        if (mappingFunction) {
            return this.cache.getAll(keys, mappingFunction);
        }
        if (this.multiLoader) {
            return this.cache.getAll(keys, this.multiLoader);
        }
        const present = this.cache.getAllPresent(keys);
        if (this.loader) {
            for (let key of keys) {
                if (!present.has(key)) {
                    present.set(key, this.get(key, this.loader));
                }
            }
        }
        return present;
    }
    ///// PUT
    put(key, value) {
        this.cache.put(key, value);
    }
    putAll(map) {
        this.cache.putAll(map);
    }
    ///// INVALIDATE
    invalidate(key) {
        this.cache.invalidate(key);
    }
    invalidateAll(keys) {
        this.cache.invalidateAll(keys);
    }
    refresh(key) {
        return this._get(key, null, true);
    }
    /////
    keys() {
        return this.cache.keys();
    }
    has(key) {
        return this.cache.has(key);
    }
    end() {
        this.cache.end();
    }
}
exports.LoadingCache = LoadingCache;
//# sourceMappingURL=LoadingCache.js.map