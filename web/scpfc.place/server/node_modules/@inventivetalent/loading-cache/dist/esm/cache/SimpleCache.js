import { CacheBase, Entry } from "./CacheBase";
import { CacheStats } from "../CacheStats";
import { asArray } from "../util";
/**
 * Simple cache without automated loading functionality
 */
export class SimpleCache extends CacheBase {
    constructor(options) {
        super(options);
    }
    ///// GET
    getIfPresent(key) {
        const entry = this.getEntryIfPresent(key);
        if (!entry) {
            return undefined;
        }
        return entry.getValue();
    }
    get(key, mappingFunction) {
        return this._get(key, mappingFunction);
    }
    /**
     * @internal
     */
    _get(key, mappingFunction, forceLoad = false) {
        if (!forceLoad) {
            const entry = this.getEntryIfPresent(key);
            if (entry) {
                return entry.getValue();
            }
        }
        if (mappingFunction) {
            const mapped = mappingFunction(key);
            if (mapped) {
                this.put(key, mapped);
            }
            if (this.options.recordStats) {
                if (mapped) {
                    this.stats.inc(CacheStats.LOAD_SUCCESS);
                }
                else {
                    this.stats.inc(CacheStats.LOAD_FAIL);
                }
            }
            return mapped;
        }
        return undefined;
    }
    /// GET ALL
    getAllPresentEntries(keys) {
        const map = new Map();
        for (let key of keys) {
            let val = this.getEntryIfPresent(key);
            if (val) {
                map.set(key, val);
            }
        }
        return map;
    }
    getAllEntries(keys) {
        return this.getAllPresentEntries(keys);
    }
    getAllPresent(keys) {
        const entryMap = this.getAllPresentEntries(keys);
        const map = new Map();
        entryMap.forEach((v, k) => map.set(k, v.getValue()));
        return map;
    }
    getAll(keys, mappingFunction) {
        const keyArray = asArray(keys);
        const present = this.getAllPresent(keys);
        if (mappingFunction && present.size < keyArray.length) {
            const missingKeys = keyArray.filter(k => !present.has(k));
            if (missingKeys.length > 0) {
                const mapped = mappingFunction(missingKeys);
                this.putAll(mapped);
                const combined = new Map();
                present.forEach((v, k) => combined.set(k, v));
                mapped.forEach((v, k) => combined.set(k, v));
                if (this.options.recordStats) {
                    this.stats.inc(CacheStats.LOAD_SUCCESS, mapped.size);
                    this.stats.inc(CacheStats.LOAD_FAIL, missingKeys.length - mapped.size);
                }
                return combined;
            }
        }
        return present;
    }
    ///// PUT
    put(key, value) {
        let entry = this.getEntryIfPresent(key, false);
        if (!entry) {
            // create new entry
            entry = new Entry(key);
        }
        // update value
        entry.setValue(value);
        this.putEntry(key, entry);
    }
    putAll(map) {
        map.forEach((v, k) => this.put(k, v));
    }
    ///// INVALIDATE
    invalidate(key) {
        super.invalidateEntry(key);
    }
    invalidateAll(keys) {
        if (!keys) {
            keys = this.keys();
        }
        for (let key of keys) {
            this.invalidate(key);
        }
    }
    refresh(key) {
        // Don't really have a way to properly refresh in SimpleCache
        return this.getIfPresent(key);
    }
}
//# sourceMappingURL=SimpleCache.js.map