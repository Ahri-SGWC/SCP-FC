import { EventEmitter } from "events";
import { CacheStats } from "../CacheStats";
import { CacheEvents } from "../CacheEvents";
import { asArray } from "../util";
import { Time } from "@inventivetalent/time";
const DEFAULT_OPTIONS = {
    expireAfterAccess: 0,
    expireAfterWrite: 0,
    deleteOnExpiration: true,
    expirationInterval: Time.minutes(5),
    recordStats: true
};
/**
 * Base class for all cache implementations
 */
export class CacheBase extends EventEmitter {
    constructor(options) {
        super({});
        this.data = new Map();
        this._stats = new CacheStats();
        this._options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        // Start cleanup task if enabled
        this.runCleanup();
        CacheEvents.forward(this._stats, this);
    }
    get options() {
        return this._options;
    }
    get stats() {
        return this._stats;
    }
    runCleanup() {
        if (this.options.deleteOnExpiration) { // don't do anything if entries shouldn't be deleted
            this.deleteExpiredEntries();
            if (this.options.expirationInterval > 0) {
                this._cleanupTimeout = setTimeout(() => this.runCleanup(), this.options.expirationInterval);
            }
        }
    }
    stopCleanupTimer() {
        clearTimeout(this._cleanupTimeout);
    }
    deleteExpiredEntries(recordStats = this.options.recordStats) {
        const toDelete = [];
        this.data.forEach(entry => {
            if (entry.isExpired(this.options)) {
                toDelete.push(entry.getKey());
                try {
                    this.emit(CacheEvents.EXPIRE, entry.getKey(), entry.getValue());
                }
                catch (e) {
                    console.error(e);
                }
            }
        });
        toDelete.forEach(k => this.data.delete(k));
        if (recordStats) {
            this.stats.inc(CacheStats.EXPIRE, toDelete.length);
        }
    }
    ///// GET
    /**
     * Get the raw entry without doing any checks
     */
    getEntryDirect(key) {
        return this.data.get(key);
    }
    /**
     * Get the entry after checking for expiration, or <code>undefined</code> if it doesn't exist or is expired
     */
    getEntryIfPresent(key, recordStats = this.options.recordStats) {
        const entry = this.getEntryDirect(key);
        if (!entry) {
            if (recordStats) {
                this.stats.inc(CacheStats.MISS);
            }
            return undefined;
        }
        if (entry.isExpired(this.options)) {
            if (this.options.deleteOnExpiration) {
                this.invalidateEntry(key);
                if (recordStats) {
                    this.stats.inc(CacheStats.EXPIRE);
                }
            }
            if (recordStats) {
                this.stats.inc(CacheStats.MISS);
            }
            return undefined;
        }
        if (recordStats) {
            this.stats.inc(CacheStats.HIT);
        }
        return entry;
    }
    ///// PUT
    putEntry(key, entry) {
        this.data.set(key, entry);
    }
    ///// INVALIDATE
    invalidateEntry(key) {
        return this.data.delete(key);
    }
    /////
    keys() {
        return asArray(this.data.keys());
    }
    has(key) {
        return this.data.has(key);
    }
    end() {
        this.stopCleanupTimer();
        this.data.clear();
    }
}
export class Entry {
    constructor(key) {
        this.key = key;
    }
    static fromJson(key, value) {
        const entry = new Entry(key);
        entry.value = value["value"];
        entry.accessTime = value["accessTime"];
        entry.writeTime = value["writeTime"];
        return entry;
    }
    getKey() {
        this.accessTime = Time.now;
        return this.key;
    }
    getValue() {
        this.accessTime = Time.now;
        return this.value;
    }
    setValue(v) {
        this.accessTime = Time.now;
        this.writeTime = Time.now;
        return this.value = v;
    }
    isExpired(options) {
        if (options.expireAfterAccess !== 0) {
            if (Time.now - this.accessTime > options.expireAfterAccess) {
                return true;
            }
        }
        if (options.expireAfterWrite !== 0) {
            if (Time.now - this.writeTime > options.expireAfterWrite) {
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=CacheBase.js.map