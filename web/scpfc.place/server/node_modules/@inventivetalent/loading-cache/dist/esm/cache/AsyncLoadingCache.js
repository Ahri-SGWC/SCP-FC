import { SimpleCache } from "./SimpleCache";
import { CacheStats } from "../CacheStats";
import { CacheEvents } from "../CacheEvents";
import { EventEmitter } from "events";
import { asArray, keyPromiseMapToPromiseContainingMap } from "../util";
export class AsyncLoadingCache extends EventEmitter {
    constructor(options, loader, multiLoader, internalCache) {
        super({});
        if (internalCache) {
            this._cache = internalCache(options);
        }
        else {
            this._cache = new SimpleCache();
        }
        this.loader = loader;
        this.multiLoader = multiLoader;
        CacheEvents.forward(this._cache, this);
    }
    get options() {
        return this.cache.options;
    }
    get cache() {
        return this._cache;
    }
    get stats() {
        return this.cache.stats;
    }
    ///// GET
    getIfPresent(key) {
        return this.cache.getIfPresent(key);
    }
    get(key, mappingFunction, forceLoad = false) {
        return this._get(key, mappingFunction, forceLoad);
    }
    /**
     * @internal
     */
    _get(key, mappingFunction, forceLoad = false) {
        if (!forceLoad) {
            const present = this.getIfPresent(key);
            if (present) {
                return present;
            }
        }
        if (mappingFunction) {
            const mapped = mappingFunction(key);
            let mappedPromise;
            if (mapped instanceof Promise) {
                mappedPromise = mapped;
            }
            else {
                mappedPromise = Promise.resolve(mapped);
            }
            this.put(key, mappedPromise);
            if (this.options.recordStats) {
                if (mapped) {
                    this.stats.inc(CacheStats.LOAD_SUCCESS);
                }
                else {
                    this.stats.inc(CacheStats.LOAD_FAIL);
                }
            }
            return mappedPromise;
        }
        if (this.loader) {
            return this._get(key, this.loader, true);
        }
        return undefined;
    }
    /// GET ALL
    getAllPresent(keys) {
        const present = this.cache.getAllPresent(keys);
        return keyPromiseMapToPromiseContainingMap(present);
    }
    getAll(keys, mappingFunction) {
        return this._getAll(keys, mappingFunction);
    }
    /**
     * @internal
     */
    _getAll(keys, mappingFunction) {
        const keyArray = asArray(keys);
        const present = this.cache.getAllPresent(keys);
        if (mappingFunction && present.size < keyArray.length) {
            const missingKeys = keyArray.filter(k => !present.has(k));
            if (missingKeys.length > 0) {
                const mapped = mappingFunction(keys);
                let mappedPromise;
                if (mapped instanceof Promise) {
                    mappedPromise = mapped;
                }
                else {
                    mappedPromise = Promise.resolve(mapped);
                }
                return Promise.all([
                    keyPromiseMapToPromiseContainingMap(present),
                    mappedPromise
                ]).then(([presentMap, newMap]) => {
                    this.putAll(newMap);
                    const combined = new Map();
                    presentMap.forEach((v, k) => combined.set(k, v));
                    newMap.forEach((v, k) => combined.set(k, v));
                    if (this.options.recordStats) {
                        this.stats.inc(CacheStats.LOAD_SUCCESS, newMap.size);
                        this.stats.inc(CacheStats.LOAD_FAIL, missingKeys.length - newMap.size);
                    }
                    return combined;
                });
            }
        }
        if (this.multiLoader) {
            return this.getAll(keys, this.multiLoader);
        }
        if (this.loader) {
            for (let key of keys) {
                if (!present.has(key)) {
                    present.set(key, this.get(key));
                }
            }
        }
        return keyPromiseMapToPromiseContainingMap(present);
    }
    put(key, value) {
        if (value instanceof Promise) {
            this.cache.put(key, value);
        }
        else {
            this.cache.put(key, Promise.resolve(value));
        }
    }
    putAll(map) {
        map.forEach((v, k) => {
            this.cache.put(k, Promise.resolve(v));
        });
    }
    ///// INVALIDATE
    invalidate(key) {
        this.cache.invalidate(key);
    }
    invalidateAll(keys) {
        this.cache.invalidateAll(keys);
    }
    refresh(key) {
        return this._get(key, null, true);
    }
    /////
    keys() {
        return this.cache.keys();
    }
    has(key) {
        return this.cache.has(key);
    }
    end() {
        this.cache.end();
    }
}
//# sourceMappingURL=AsyncLoadingCache.js.map